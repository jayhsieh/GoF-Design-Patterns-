Study Case 1.

在物件導向的設計中經常可以遇到以下兩類問題:

(1) 為了提高內聚(Cohesion)和鬆耦合(Coupling)，經常會抽象出一些類的公共接口以形成抽象基類或者接口
    當 n 個子類繼承自抽象基類，我們不得不在每次要用到子類的地方就編寫如 new xxx 的建構式
    或者在 python 中為產生實例的寫法  aaa = xxx()

    因而衍生兩個問題:
    (a) 接手的軟體開發工程師必須要知道實際子類的名稱。當系統複雜後，命名將是一個不好處理的問題
        為了避免名字衝突，有的命名可能並不是有很好的可讀性或者記憶性
    (b) 程式的擴展性和維護變得越來越困難

(2) 在父類中並不知道具體要實例化哪一個具體的子類。例如: 類 A 中要使用到類 B，B 是一個抽象父類
    在 A 中並不知道具體要實例化哪一個 B 的子類 C，但是在類 A 的子類 D 中是可以知道的

    A: Logistics()
    B: Transport()

    D: RoadLogistics()
    C: Truck()


=====
以上問題引出 Factory 模式的兩個最重要的功能

(1) 定義創建對象的接口，封裝了對象的創建 (rows 11 to 18)
(2) 使得具體化類的工作延遲到了子類中 (row 30-31, 38-39)

Factory 的缺點:
Factory Method 僅僅侷限於一類，也就是有一個共同的基類
如果要為不同類提供一個對象創建的接口，那就要用 abstract factory

SRP: 創建 product 的程式碼都在同一個地方 (factory_method)，而使其更容易維護
OCP: 因為送貨方法和 product 類型無關，所以就算加入新的 product 類型也無需更改送貨方法
LSP: 工廠方法 factory_method 返回 Transport 的子類